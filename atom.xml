<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Wengthon的个人博客</title>
  <subtitle>前端技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-08-09T11:28:44.554Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Wengthon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ajax学习笔记</title>
    <link href="http://yoursite.com/2017/08/09/Ajax/"/>
    <id>http://yoursite.com/2017/08/09/Ajax/</id>
    <published>2017-08-08T16:00:00.000Z</published>
    <updated>2017-08-09T11:28:44.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><h2 id="get和post方式的简单说明"><a href="#get和post方式的简单说明" class="headerlink" title="get和post方式的简单说明"></a>get和post方式的简单说明</h2><h3 id="get方式"><a href="#get方式" class="headerlink" title="get方式"></a>get方式</h3><pre><code>格式：协议 + 主机地址 + 资源路径 + ? + 参数1 &amp; 参数2 &amp; 参数3
1.  参数的处理方式  ==&gt; 在URL后面
2.  大小的限制   ==&gt;   有限制
3.  安全性     ==&gt;  较差
4.  通过$_GET 获取信息
</code></pre><h3 id="post-方式"><a href="#post-方式" class="headerlink" title="post 方式"></a>post 方式</h3><pre><code>格式：协议 + 主机地址 + 资源路径
1. 参数的处理方式      请求体
2. 大小的限制          没有限制
3. 安全性              相对安全
4. 通过$_POST 获取信息
</code></pre><h2 id="表单提交和ajax请求的区别"><a href="#表单提交和ajax请求的区别" class="headerlink" title="表单提交和ajax请求的区别"></a>表单提交和ajax请求的区别</h2><ul>
<li>表单提交会默认跳转到php页面  并将php返回的结果显示在浏览器</li>
<li>ajax 只是发送了网络请求  响应只会在response中  不会显示在浏览器上<h2 id="解决安全问题-加密"><a href="#解决安全问题-加密" class="headerlink" title="解决安全问题-加密"></a>解决安全问题-加密</h2><blockquote>
<p>在处理安全问题的时候,如果有隐私数据需要传递服务器，就需要将数据加密  </p>
<h3 id="消息摘要算法-哈希算法-散列计算-–-gt-MD5-sha256"><a href="#消息摘要算法-哈希算法-散列计算-–-gt-MD5-sha256" class="headerlink" title="消息摘要算法(哈希算法|散列计算) –&gt;MD5 | sha256"></a>消息摘要算法(哈希算法|散列计算) –&gt;MD5 | sha256</h3></blockquote>
</li>
<li>特点:<ul>
<li>给定数据,进行散列计算之后,会得到一个定长的字符串</li>
<li>加密之后得到的数据是定长的</li>
<li>相同的明文加密之后得到的密文是相同</li>
<li>只要明文不同,那么密文一定不同  ==&gt; 正版校验</li>
<li>不可逆的 —&gt;可以暴力破解(在大型数据库中查找)</li>
<li>速度快,效率高</li>
</ul>
</li>
</ul>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><ul>
<li>经典算法:<ul>
<li>DES(数据加密标准) </li>
<li>AES(高级数据加密标准) </li>
<li>3DES</li>
</ul>
</li>
<li>特点：<ul>
<li>速度快,效率高</li>
<li>有一个密钥（yue） 加密和解密使用相同的密钥</li>
<li>问题：密钥传输安全的问题</li>
</ul>
</li>
</ul>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><ul>
<li>经典算法：RSA</li>
<li>特点：<ul>
<li>安全性非常高</li>
<li>有两个密钥，公钥用来加密，私钥用来解密</li>
<li>公钥一般来说可以公开，私钥是绝对不可以公开。</li>
<li>问题：性能很差</li>
</ul>
</li>
</ul>
<h3 id="证书-https"><a href="#证书-https" class="headerlink" title="证书-https"></a>证书-https</h3><blockquote>
<p> 解决问题：对称加密算法|非对称加密算法</p>
</blockquote>
<h2 id="文件上传的知识点"><a href="#文件上传的知识点" class="headerlink" title="文件上传的知识点"></a>文件上传的知识点</h2><ul>
<li><p>请求方式：POST</p>
<ul>
<li>设置属性enctype</li>
<li>获取上传的文件，需要设置 name</li>
<li>通过$_FILES获取信息</li>
<li><p>文件上传到服务器端后会保存到临时路径，随后被删除，因此需要我们转移到安全的地方</p>
<pre><code>[filename] =&gt; Array
(
 [name] =&gt; 2345截图20170629173445.jpg    文件的名称
 [type] =&gt; image/jpeg              文件的类型（MIMETYPE）
 [tmp_name] =&gt; E:\wamp\tmp\php8DEF.tmp  文件在服务器上的临时存储路径，随时会被删除
 [error] =&gt; 0                           错误信息
 [size] =&gt; 18627                        文件的大小
)
</code></pre></li>
</ul>
</li>
<li><p>转移文件到安全的地方</p>
<ul>
<li>第一个参数：这个文件在哪里</li>
<li><p>第二个参数：要把这个文件移动到什么地方</p>
<pre><code>$sourcePath = $\_FILES[&quot;fileName&quot;][&quot;tmp\_name&quot;];
$name = $\_FILES[&quot;fileName&quot;][&quot;name&quot;];
$targetPath = &quot;../File/&quot;.$name;
move\_uploaded\_file($sourcePath,$targetPath);
</code></pre></li>
</ul>
</li>
<li>解决文件上传后文件名出现乱码的问题  $name=iconv(“UTF-8”,”gb2312”, $name);</li>
</ul>
<h2 id="大文件上传的知识点"><a href="#大文件上传的知识点" class="headerlink" title="大文件上传的知识点"></a>大文件上传的知识点</h2><blockquote>
<h3 id="大文件上传需要配置服务器端的环境"><a href="#大文件上传需要配置服务器端的环境" class="headerlink" title="大文件上传需要配置服务器端的环境"></a>大文件上传需要配置服务器端的环境</h3></blockquote>
<pre><code> 左键点击 ==&gt; php文件夹 ==&gt; pnp.ini ==&gt;
file_uploads = On               是否允许上传文件 On/Off 默认是On
upload_max_filesize = 2048M     上传文件的最大限制
post_max_size = 2048M           通过Post提交的最多数据
max_execution_time = 30000      脚本最长的执行时间 单位为秒
max_input_time = 30000          接收提交的数据的时间限制 单位为秒
memory_limit = 2048M            最大的内存消耗
</code></pre><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="请求的状态"><a href="#请求的状态" class="headerlink" title="请求的状态"></a>请求的状态</h3><pre><code>（1）请求未初始化 -- 0
（2）服务器连接已经建立 -- 1
（3）请求已经接收 --2
（4）请求处理中 --3
（5）请求已经完成,且响应已经就绪 --4
</code></pre><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><pre><code>200    OK    请求成功
400    Bad Request    （客户端请求的语法错误），服务器无法解析
404    Not Found    服务器无法根据客户端的请求找到资源
500    Internal Server Error    服务器内部错误，无法完成请求
</code></pre><h3 id="解决浏览器缓存问题"><a href="#解决浏览器缓存问题" class="headerlink" title="解决浏览器缓存问题"></a>解决浏览器缓存问题</h3><blockquote>
<p>部分浏览器，如果多次发送GET网络请求请求的URL是一样的，那么会直接返回缓存文件<br>如果当前的接口需要实时的获取最新的数据，可以设置url，让url每次都不一样即可<br>在url最后面拼接上&amp;t=Math.random()/new Date().valueOf()/new Date().getTime()</p>
<h3 id="GET请求参数中文的问题"><a href="#GET请求参数中文的问题" class="headerlink" title="GET请求参数中文的问题"></a>GET请求参数中文的问题</h3><pre><code>在发送请求前将URL转码  url = encodeURI(url)
</code></pre><h3 id="请求超时处理"><a href="#请求超时处理" class="headerlink" title="请求超时处理"></a>请求超时处理</h3><p>如果在指定的时间内获取了服务器返回的数据，<br>正常处理；如果在指定的时间内没有拿到数据，取消（放弃）整个网络请求</p>
</blockquote>
<pre><code>var timer  = setInterval(function () {xhr.abort();},timout)
</code></pre><h3 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h3><pre><code>（1）在open方法中第一个参数设置为post
（2）提交给服务器端的参数放在send方法中传递（固定的格式）
（3）如果提交了参数，那么需要设置请求头信息
（4）注意设置请求头这行代码的位置，要在open方法和send方法中间
</code></pre><h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><pre><code>$_REQUEST 不管发送的GET请求还是POST请求都可以通过$_REQUEST对象来获取内部的数据
$_REQUEST变量包含$_GET, $_POST, and $_COOKIE的内容
</code></pre><h2 id="封装AJAX"><a href="#封装AJAX" class="headerlink" title="封装AJAX"></a>封装AJAX</h2><pre><code>function AJAX (obj) {
var objparams = obj[&quot;data&quot;];
var type = obj[&quot;type&quot;] || &quot;get&quot;;
var url = obj[&quot;url&quot;];
var timeout = obj[&quot;timeout&quot;] || 1000;
//01创建请求对象 (兼容性)
var xhr = null;
if(window.XMLHttpRequest){
    xhr =  new  XMLHttpRequest();
}else{
    xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
}
//02 设置请求路径和请求方法（get|post）
//第一个参数：请求方法（get|post）
//第二个参数：请求路径
//第三个参数：是否发送异步请求（总是true）
//var count = Math.random();
//var count = new Date().getTime();
var arr = [];
for(var key in objparams){
    arr.push(key + &apos;=&apos; + objparams[key]);
}
var res = arr.join(&apos;&amp;&apos;);
var count = new Date().getTime();

if(type == &apos;get&apos;){
    url+= &apos;?t=&apos;+count+ &apos;&amp;&apos; +res;
    url = encodeURI(url);
    xhr.open(type,url,true);
    xhr.send();
}else if(type == &apos;post&apos;){
    //post 方式不用随机参数  不用参数中文转码
    xhr.open(type,url,true);
    xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);
    xhr.send(res);
}

//03发送请求

//04监听请求的状态
xhr.onreadystatechange = function () {
    //当请求的状态发生了改变就会执行这个回调中的代码
    //请求的状态：
    /*
     *（1）请求未初始化 - 0
     （2）服务器连接已经建立 - 1
     （3）请求已经接收 -2
     （4）请求处理中 -3
     （5）请求已经完成，且响应已经就绪 -4
     * */
    //判断当前的请求是否完成（接收到响应）
    if(xhr.readyState ==4){
        clearInterval(timer);
        //console.log(xhr.status)
        if(xhr.status == 200){
            //05 解析服务器返回的数据 xhr.responseText
            obj.success(xhr.responseText);
        }else{
            obj.error(xhr.status);
        }
    }
}

var timer  = setInterval(function () {
    //如果在指定的时间内获取了服务器返回的数据，正常处理
    //如果在指定的时间内没有拿到数据，取消（放弃）整个网络请求
    xhr.abort();
},timeout);}
</code></pre><h2 id="jQuery-Ajax"><a href="#jQuery-Ajax" class="headerlink" title="jQuery Ajax"></a>jQuery Ajax</h2><h3 id="get-post"><a href="#get-post" class="headerlink" title="$.get/$.post"></a>$.get/$.post</h3><pre><code>jQuery.get(url, [data], [callback], [type])
type 返回内容的格式 =&gt; xml, html, script, json, text, _default
</code></pre><h3 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax"></a>$.ajax</h3><pre><code>常见参数 url type(get/post)  data success  error
格式  $.ajax(url,{})/$.ajax({})
如果回调函数是JSON对象  不必把JSON对象转化成JS对象  内部会默认处理
</code></pre><h2 id="JS中JSON的处理"><a href="#JS中JSON的处理" class="headerlink" title="JS中JSON的处理"></a>JS中JSON的处理</h2><pre><code>序列化:把对象转换为JSON字符串，可以使用JSON.stringify 序列化
反序列化：把JSON字符串转换为js（其他语言）对象,可以使用JSON.parser|eval方法  反序列化
</code></pre><h2 id="PHP中JSON的处理"><a href="#PHP中JSON的处理" class="headerlink" title="PHP中JSON的处理"></a>PHP中JSON的处理</h2><pre><code>把PHP对象转换为JSON字符串 json_encode  序列化
把JSON字符串转换为PHP对象 json_decode  反序列化
</code></pre><h2 id="PHP文件中的处理"><a href="#PHP文件中的处理" class="headerlink" title="PHP文件中的处理"></a>PHP文件中的处理</h2><pre><code>显示的指定返回值是XML格式的header(&quot;Content-Type: text/xml(json); charset=utf-8&quot;);
使用file_get_contents方法读取XML文档并返回
</code></pre><h2 id="XML数据处理"><a href="#XML数据处理" class="headerlink" title="XML数据处理"></a>XML数据处理</h2><pre><code>（1）XML是一种标记型语言，和HTML类型，主要用于表示和传输数据
（2）服务器返回给客户端的数据大部分是JSON或者是XML格式的
（3）XML文档结构主要由三部分组成
    文档声明 + 元素（开始和结尾标签） + 属性
（4）XML的使用注意
            01 标准的XML文档只有一个根节点
            02 XML的使用方式和HTML非常相似，在请求对象中有responseXML属性 直接返回xhr对象
               03 相对于JSON来说，XML体积较大
</code></pre><h2 id="JSON数据处理"><a href="#JSON数据处理" class="headerlink" title="JSON数据处理"></a>JSON数据处理</h2><pre><code>（1）JSON是一种轻量级的数据结构
（2）服务器返回给客户端的数据大部分是JSON或者是XML格式的
（3）JSON本身是有特殊格式的字符串，JSON数据的最外层通常为[]或者是{}，对应于对象中的数组和对象
（4）JSON和js简单对比
     01 标准的JSON数据所有的key都加双引号
        02 JSON中key对应的全部都是具体的属性值，而对象中存放的可能是函数
</code></pre><h2 id="创建JS代码模板"><a href="#创建JS代码模板" class="headerlink" title="创建JS代码模板"></a>创建JS代码模板</h2><pre><code>(1) 下载相关的仓库，获取框架
(2) 导入框架  template-web.js
(3) 提供一个script标签，把具体的要作为模板来处理的代码放在里面
(4) 具体使用,调用template方法来传递参数（id,对象）
</code></pre><h3 id="方式1-原生模板"><a href="#方式1-原生模板" class="headerlink" title="方式1:原生模板"></a>方式1:原生模板</h3><pre><code>&lt;script type=&quot;text/html&quot; id=&quot;demoT&quot;&gt;
    &lt;ul&gt;
        &lt;% for(var i = 0;i&lt; data.length ;i++){ %&gt;
            &lt;li&gt;&lt;%=data[i]%&gt;&lt;/li&gt;
        &lt;%}%&gt;
    &lt;/ul&gt;
&lt;/script&gt;
var html = template(&quot;demoT&quot;,obj);
</code></pre><h3 id="方式2-基础模板"><a href="#方式2-基础模板" class="headerlink" title="方式2:基础模板"></a>方式2:基础模板</h3><pre><code>&lt;script id=&quot;test&quot; type=&quot;text/html&quot;&gt;
    {{if isAdmin}}
    &lt;h1&gt;{{title}}&lt;/h1&gt;
    &lt;ul&gt;
        {{each list as value i}}
            &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;
        {{/each}}
    &lt;/ul&gt;
    {{/if}}
&lt;/script&gt;
</code></pre><h2 id="常见的存储技术"><a href="#常见的存储技术" class="headerlink" title="常见的存储技术"></a>常见的存储技术</h2><h3 id="cookie存储"><a href="#cookie存储" class="headerlink" title="cookie存储"></a>cookie存储</h3><blockquote>
<p>cookie是一种会话跟踪技术，用于在进行网页访问的时候，存储页面中的某些数据信息</p>
</blockquote>
<ul>
<li>使用cookie来进行数据存储的大小有限制，4KB</li>
<li>每个网页中存储cookie的个数（最多50）和每个网站中存储cookie的个数都有限制（200）</li>
<li>各个不同的浏览器对cookie的数量也不相同 在进行页面cookie操作的时候，应该尽量保证cookie个数小于20个，总大小 小于4KB</li>
<li>cookie数据的过期时间<ul>
<li>默认情况下，cookie存储的内容是一次性的，它的有效期间是当前会话（需要把整个浏览器都关闭会话就结束）</li>
<li>设置过期时间：通过expires=time;的格式来进行指定, 设置了之后只(5)okie是不可以跨浏览器的(在IE中保存的cookie, 不可以在火狐中使用)</li>
</ul>
</li>
<li>cookie是不可以跨域的(跨域名)</li>
</ul>
<blockquote>
<p>示例：127.0.0.1/code/test.html 和127.0.0.1/code/&gt; test1.html可以访问<br>不能跨域的含义：就是只有 （协议+域名+后缀+端口）号都相同才能相互访问</p>
<h4 id="cookie的设置和使用"><a href="#cookie的设置和使用" class="headerlink" title="cookie的设置和使用"></a>cookie的设置和使用</h4><ul>
<li>设置方法：<ul>
<li>设置cookie数据：document.cookie = “name=zhangsan”;</li>
<li>设置cookie数据和过期的时间：<br>document.cookie = “name=zhangsan; expires=”+date+”;”;</li>
<li>过期7天的设置：<br>var date = new Date();  date.setDate(date.getDate() + 7);</li>
<li>使用注意：<br>在设置cookie的时候，一次只能设置一个数据（一个键值对），不能进行批量设置<br>错误的演示：window.cookie = “name=zhangsan&amp;age=18”;<ul>
<li>删除cookie<br>删除cookie的原理：只要过期时间超过了当前的时间, 数据就会被删除<br>date.setDate(date.getDate() + -1);</li>
</ul>
</li>
<li>查询  使用字符串分割的方法</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="sessionStorage存储"><a href="#sessionStorage存储" class="headerlink" title="sessionStorage存储"></a>sessionStorage存储</h3><pre><code>（1）在存储用户数据的时候，因为cookie可以存储的数据比较小才4KB左右，所以也可以考虑使用sessionStorage来存储,大小限制为2M左右
（2）该技术和localStorage是h5推出的，因此在使用的时候，需要考虑到兼容性的问题
（3）相关资料：http://www.w3school.com.cn/html5/html_5_webstorage.asp
（4）简单介绍和使用：
    01 sessionStorage：会话存储技术（session-会话）
    02 该技术和cookie一样，一样浏览器退出了，那么保存的数据就会被销毁
    03 演示sessionStorage技术的相关操作
        添加|获取|更新|删除|清空
       window.sessionStorage.setItem(&quot;age&quot;,&quot;18&quot;);
       window.sessionStorage.getItem(&quot;name&quot;);
       window.sessionStorage.setItem(&quot;name&quot;,&quot;zhangsan&quot;);
       window.sessionStorage.removeItem(&quot;name&quot;);
       window.sessionStorage.clear();
</code></pre><h3 id="localStorage存储"><a href="#localStorage存储" class="headerlink" title="localStorage存储"></a>localStorage存储</h3><pre><code>（1）简单对比：保存在本地 + 没有时间限制
（2）大小比较：4K - 5M - 20M
（3）使用方式和sessionStorage相同
    添加|获取|更新|删除|清空  用法同上 sessionStorage
</code></pre><h3 id="hash简单介绍"><a href="#hash简单介绍" class="headerlink" title="hash简单介绍"></a>hash简单介绍</h3><pre><code>如果在对应的代码中设置了hash的值，那么在访问的时候，
当前页面的URL后面会跟上hash的值，表现为url路径 + #页码
window.location.hash = &quot;3&quot;
</code></pre><h3 id="应用程序缓存"><a href="#应用程序缓存" class="headerlink" title="应用程序缓存"></a>应用程序缓存</h3><pre><code>（1）简单介绍：h5推出的应用程序缓存，可以对Web页面进行缓存，并且可以在没有网络的情况下进行访问
兼容说明：所有主流浏览器均支持应用程序缓存，除了 Internet Explorer
（2）主要优点：
    1）支持离线浏览（没有网络的情况下依然可以查看）
    2）速度更快，性能更好（使用缓存文件可以提高访问的速度）
    3）减轻服务器端的压力 - 浏览器将只从服务器下载更新过或更改过的资源
（3）代码演示
    1）在页面中加载资源文件（图片），调试工具窗口选择（none network）表示网络无法连接
    2）新创建xx.appcache文件，在该文件配置要缓存的内容
    3）设置html页面中的manifest属性为配置文件路径
（4）配置文件示例
    CACHE MANIFEST

    CACHE:
    # 需要缓存的列表
    0.jpg

    NETWORK:
    # 不需要缓存的
    1.jpg

    FALLBACK:
    # 访问缓存失败后，备用访问的资源，第一个是访问源，第二个是替换文件
    *.html /offline.html
    2.jpg /3.jpg
</code></pre><h2 id="实现跨域网络访问-script实现"><a href="#实现跨域网络访问-script实现" class="headerlink" title="实现跨域网络访问  script实现"></a>实现跨域网络访问  script实现</h2><blockquote>
<p>基于script标签和scr属性节点的特点，我们可以考虑在页面中利用此特性来实现跨域请求</p>
<ul>
<li>在页面中提供第一个script标签，在该标签中声明函数（设置形参）</li>
<li>提供第二个script标签，把需要跨域访问的路径设置为该标签的src</li>
<li>在对应的路径中，返回固定格式的JSON数据【函数名称(对象)】  </li>
<li>在声明的函数中对形参进行处理（形参就是跨域请求返回的数据）<br>  注意点  document.body.appendChild(scriptTag); 在往页面中添加script标签的时候一定要用原生写  否则会报错<h2 id="jQuery-jsonp实现"><a href="#jQuery-jsonp实现" class="headerlink" title="jQuery jsonp实现"></a>jQuery jsonp实现</h2>   $.ajax({<pre><code>        type : &quot;get&quot;,
        async: false,
        url : &quot;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=&quot;+textVal+&quot;&amp;cb=callBack&quot;,
        dataType : &quot;jsonp&quot;,
        jsonp: &quot;cb&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)
        jsonpCallback:&quot;callBack&quot;,
//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名(类似：jQuery1102016820125747472048_1450147653563([&quot;zhangsan&quot;, &quot;lisi&quot;, &quot;wangwu&quot;]);)
        success : function(data){
            console.log(data);
        },
        error:function(){
            console.log(&apos;fail&apos;);
        }
    });
</code></pre></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ajax&quot;&gt;&lt;a href=&quot;#Ajax&quot; class=&quot;headerlink&quot; title=&quot;Ajax&quot;&gt;&lt;/a&gt;Ajax&lt;/h1&gt;&lt;h2 id=&quot;get和post方式的简单说明&quot;&gt;&lt;a href=&quot;#get和post方式的简单说明&quot; class=&quot;header
    
    </summary>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>常见的代码托管平台</title>
    <link href="http://yoursite.com/2017/08/09/%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2017/08/09/代码托管平台/</id>
    <published>2017-08-08T16:00:00.000Z</published>
    <updated>2017-08-09T05:30:52.388Z</updated>
    
    <content type="html"><![CDATA[<p>1、GitHub</p>
<p>关于GItHub相信大家都有耳闻，我就不详细介绍了。GitHub地址：<a href="https://github.com/" target="_blank" rel="external">https://github.com/</a></p>
<p>2、Gitlab</p>
<p>对于有些人，提到GitHub就会自然的想到Gitlab,Gitlab支持无限的公有项目和私有项目。Gitlab地址：<a href="https://about.gitlab.com/" target="_blank" rel="external">https://about.gitlab.com/</a></p>
<p>3、Bitbucket</p>
<p>bitbucket 免费支持5个开发成员的团队创建无限私有代码托管库 。bitbucket地址：<a href="https://bitbucket.org/" target="_blank" rel="external">https://bitbucket.org/</a></p>
<p>4、(推荐)开源中国代码托管</p>
<p>前面说的都是国外的，下面来说几个国内的。开源中国一个账号最多可以创建1000个项目，包含公有和私有，开源中国代码托管地址：<a href="http://git.oschina.net/" target="_blank" rel="external">http://git.oschina.net/</a></p>
<p>开源中国在几个月前又发布了团队协作开发平台，和代码托管平台一起，打造了一个十分好的团队开发平台，开源中国团队协作平台地址：<a href="http://team.oschina.net/，团队协作平台支持任务的创建、讨论、便签等，如图：" target="_blank" rel="external">http://team.oschina.net/，团队协作平台支持任务的创建、讨论、便签等，如图：</a></p>
<p>5、(推荐)coding.net</p>
<p>谈到coding.net,首先必须提的是速度快，功能与开源中国相似，同样一个账号最多可以创建1000个项目，也支持任务的创建等。coding.net地址：<a href="https://coding.net/home.html，其首页如图：" target="_blank" rel="external">https://coding.net/home.html，其首页如图：</a></p>
<p>6、CSDN代码托管</p>
<p>CSDN代码托管地址：<a href="https://code.csdn.net/" target="_blank" rel="external">https://code.csdn.net/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、GitHub&lt;/p&gt;
&lt;p&gt;关于GItHub相信大家都有耳闻，我就不详细介绍了。GitHub地址：&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/&lt;/a&gt;&lt;/
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
